use std::{
    borrow::Cow,
    time::{Duration, SystemTime, UNIX_EPOCH},
};

use redis::{streams::StreamId, AsyncCommands};
use serde::{de::DeserializeOwned, Serialize};

use crate::error::Result;

use super::{RedisBroker, STREAM_DATA_KEY, STREAM_TIMEOUT_KEY};

/// A message received from the broker.
#[derive(Debug, Clone)]
pub struct Message<'broker, V> {
    /// The group this message belongs to.
    pub group: &'broker str,
    /// The event this message signals.
    pub event: Cow<'broker, str>,
    /// The ID of this message (generated by Redis).
    pub id: String,
    /// The data of this message. Always present unless there is a bug with a client implementation.
    pub data: Option<V>,
    /// When this message times out. Clients should cancel work if it is still in progress after
    /// this instant.
    pub timeout_at: Option<SystemTime>,
    broker: &'broker RedisBroker<'broker>,
}

impl<'broker, V> PartialEq for Message<'broker, V> {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl<'broker, V> Eq for Message<'broker, V> {}

impl<'broker, V> Message<'broker, V>
where
    V: DeserializeOwned,
{
    pub(crate) fn new(
        id: StreamId,
        group: &'broker str,
        event: Cow<'broker, str>,
        broker: &'broker RedisBroker,
    ) -> Self {
        let data = id
            .get(STREAM_DATA_KEY)
            .and_then(|data: Vec<u8>| rmp_serde::from_read_ref(&data).ok());

        let timeout_at = id
            .get(STREAM_TIMEOUT_KEY)
            .map(|timeout| UNIX_EPOCH + Duration::from_nanos(timeout));

        Message {
            group,
            event,
            id: id.id,
            data,
            timeout_at,
            broker,
        }
    }
}

impl<'broker, V> Message<'broker, V> {
    /// Acknowledge receipt of the message. This should always be called, since un-acked messages
    /// will be reclaimed by other clients.
    pub async fn ack(&self) -> Result<()> {
        self.broker
            .pool
            .get()
            .await?
            .xack(&*self.event, self.group, &[&self.id])
            .await?;

        Ok(())
    }

    /// Reply to this message.
    pub async fn reply(&self, data: &impl Serialize) -> Result<()> {
        let key = format!("{}:{}", self.event, self.id);
        let serialized = rmp_serde::to_vec(data)?;
        self.broker
            .pool
            .get()
            .await?
            .publish(key, serialized)
            .await?;

        Ok(())
    }
}
