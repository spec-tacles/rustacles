use std::time::{Duration, SystemTime, UNIX_EPOCH};

use arcstr::ArcStr;
use redis::{streams::StreamId, AsyncCommands};
use serde::{de::DeserializeOwned, Serialize};

use crate::error::Result;

use super::{RedisBroker, STREAM_DATA_KEY, STREAM_TIMEOUT_KEY};

/// A message received from the broker.
#[derive(Debug)]
pub struct Message<V> {
    /// The group this message belongs to.
    pub group: ArcStr,
    /// The event this message signals.
    pub event: ArcStr,
    /// The ID of this message (generated by Redis).
    pub id: String,
    /// The data of this message. Always present unless there is a bug with a client implementation.
    pub data: Option<V>,
    /// When this message times out. Clients should cancel work if it is still in progress after
    /// this instant.
    pub timeout_at: Option<SystemTime>,
    broker: RedisBroker,
}

impl<V> PartialEq for Message<V> {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl<V> Eq for Message<V> {}

impl<V> Message<V>
where
    V: DeserializeOwned,
{
    pub(crate) fn new(id: StreamId, group: ArcStr, event: ArcStr, broker: RedisBroker) -> Self {
        let data = id
            .get(STREAM_DATA_KEY)
            .and_then(|data: Vec<u8>| rmp_serde::from_read_ref(&data).ok());

        let timeout_at = id
            .get(STREAM_TIMEOUT_KEY)
            .map(|timeout| UNIX_EPOCH + Duration::from_nanos(timeout));

        Message {
            group,
            event,
            id: id.id,
            data,
            timeout_at,
            broker,
        }
    }
}

impl<V> Message<V> {
    /// Acknowledge receipt of the message. This should always be called, since un-acked messages
    /// will be reclaimed by other clients.
    pub async fn ack(&self) -> Result<()> {
        self.broker
            .pool
            .get()
            .await?
            .xack(&*self.event, &*self.group, &[&self.id])
            .await?;

        Ok(())
    }

    /// Reply to this message.
    pub async fn reply(&self, data: &impl Serialize) -> Result<()> {
        let key = format!("{}:{}", self.event, self.id);
        let serialized = rmp_serde::to_vec(data)?;
        self.broker
            .pool
            .get()
            .await?
            .publish(key, serialized)
            .await?;

        Ok(())
    }
}
